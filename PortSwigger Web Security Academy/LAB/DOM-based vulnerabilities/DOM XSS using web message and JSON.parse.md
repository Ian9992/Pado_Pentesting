# DOM XSS using web messages and JSON.parse
* This lab uses web messaging and parses the message as JSON. To solve the lab, construct an HTML page on the exploit server that exploits this vulnerability and calls the `print()` function.

### 1. Enumerate the web page
* From the page source of the home page, `addEventListener()` that expects a string that is parsed using `JSON.parse()`

![10](https://user-images.githubusercontent.com/53956303/154377644-e528c71c-ce2f-4461-a2d6-1a62d01eed09.png)
* The event listener expects a `type` property and that the `load-channel` case of the `switch` statement changes the `iframe src` attribute.

### 2. Create a malicous iframe on the provided exploit server
```html
<iframe src=https://ace41f881f631adcc0db60b500ad007c.web-security-academy.net/ onload='this.contentWindow.postMessage("{\"type\":\"load-channel\",\"url\":\"javascript:print()\"}","*")'>
```
![11](https://user-images.githubusercontent.com/53956303/154379884-43342181-a13c-4ce8-9ce4-36cb25f01c42.png)
* When the `iframe` loads, the `postMessage()` method sends a web message to the home page with the type `load-channel`. The event listener receives the message and parses it using `JSON.parse()` before sending it to the `switch`.
	* The `switch` triggers the `load-channel`, which assigns the `url` property of the message to the `src` attribute of the `ACMEplayer.element iframe`.
		* However, in this case, the `url` property of the message actually contains our JavaScript payload.
* As the second argument specifies that any `targetOrigin` is allowed for the web message, and the event hander does not contain any form of origin check, the payload is set as the `src` fo the `ACMEplayer.element iframe`.
	* The `print()` function is called when the victim loads the page in their browser.

### 3. Send the exploit
* Store and deliver the exploit to victim.
	* As a result, the lab is solved.

![12](https://user-images.githubusercontent.com/53956303/154380531-968b47ff-a066-4954-ae24-93afd97c5628.png)
